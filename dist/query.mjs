import{fromEnv as w,fromIni as h}from"@aws-sdk/credential-providers";import{StartQueryExecutionCommand as g,GetQueryExecutionCommand as C,AthenaClient as S,GetQueryResultsCommand as Q}from"@aws-sdk/client-athena";let i=null;async function k(l,e={}){if(!l||typeof l!="string")throw new Error('query string is required (e.g. SELECT * FROM "sales" limit 10;)');if(!e.output)throw new Error("output location is required (e.g. s3://bucket/path)");e.database=e.database||"default",e.workgroup=e.workgroup||"primary",e.catalog=e.catalog||"AwsDataCatalog",e.backoff=e.backoff||1e3,e.region=e.region||"us-east-2";let c=null;e.profile?c=h({profile:e.profile}):c=w(),i===null&&(i=new S({region:e.region,credentials:c}));const f=await i.send(new g({QueryString:l,WorkGroup:e.workgroup,QueryExecutionContext:{Database:e.database||"default",Catalog:e.catalog||"AwsDataCatalog"},ResultConfiguration:{OutputLocation:e.output.startsWith("s3://")?e.output:`s3://${e.output}`}}));if(f.$metadata.httpStatusCode!==200)throw new Error("failed query");let d=0,y=e.backoff;const m=async()=>new Promise((n,a)=>{setTimeout(async()=>{const t=await i.send(new C({QueryExecutionId:f.QueryExecutionId}));t.$metadata.httpStatusCode!==200&&a(new Error("FailedQuery: unable to query Athena")),t.QueryExecution.Status.State==="SUCCEEDED"?n(t):t.QueryExecution.Status.State==="FAILED"?(console.log(t.QueryExecution),a(new Error("FailedQuery: unable to query Athena"))):t.QueryExecution.Status.State==="CANCELLED"?a(new Error("FailedQuery: unable to query Athena")):(t.QueryExecution.Status.State==="RUNNING"||t.QueryExecution.Status.State==="QUEUED")&&(d++,y=e.backoff+d*100,m().then(n).catch(a))},y)});await m().catch(n=>{throw new Error(n)});const s=await i.send(new Q({QueryExecutionId:f.QueryExecutionId}));if(s.$metadata.httpStatusCode!==200)throw new Error("FailedQuery: unable to query Athena");const u=s.ResultSet.ResultSetMetadata.ColumnInfo.map(n=>({name:n.Name,type:n.Type}));s.ResultSet.Rows.shift();const E=s.ResultSet.Rows.map(n=>{const a={};return n.Data.forEach((t,o)=>{if(Object.keys(t).length===0)return;t.VarCharValue===null&&(a[u[o].name]=null);const r=u[o].type;if(r==="date"||r==="timestamp"){a[u[o].name]=new Date(t.VarCharValue);return}if(r==="tinyint"||r==="smallint"||r==="integer"||r==="bigint"){a[u[o].name]=parseInt(t.VarCharValue);return}if(r==="double"||r==="float"||r==="decimal"){a[u[o].name]=parseFloat(t.VarCharValue);return}r==="boolean"&&(a[u[o].name]=t.VarCharValue==="true"),a[u[o].name]=t.VarCharValue}),a});return{columns:u,rows:E}}export{k as query};
