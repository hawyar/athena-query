import{defaultProvider as w}from"@aws-sdk/credential-provider-node";import{StartQueryExecutionCommand as g,GetQueryExecutionCommand as C,AthenaClient as Q,GetQueryResultsCommand as S}from"@aws-sdk/client-athena";let i=null;async function A(l,e={}){if(!l||typeof l!="string")throw new Error("query string is required");if(!e.bucket)throw new Error("output bucket is required");e.database=e.database||"default",e.workgroup=e.workgroup||"primary",e.catalog=e.catalog||"AwsDataCatalog",e.bucket=e.bucket||"dundermifflinco-output",e.backoff=e.backoff||1e3,e.profile=e.profile||"default",e.region=e.region||"us-east-2";const d=await w({profile:e.profile})();if(!d.accessKeyId||!d.secretAccessKey)throw new Error("unable to load AWS credentials");i===null&&(i=new Q({region:e.region,credentials:w({profile:e.profile}),maxAttempts:10}));const E=new g({QueryString:l,WorkGroup:e.workgroup,QueryExecutionContext:{Database:e.database||"default",Catalog:e.catalog||"AwsDataCatalog"},ResultConfiguration:{OutputLocation:e.bucket.startsWith("s3://")?e.bucket:`s3://${e.bucket}`}}),c=await i.send(E);if(c.$metadata.httpStatusCode!==200)throw new Error("FailedQuery: unable to query Athena");let f=0,y=e.backoff;const m=async()=>new Promise((n,a)=>{setTimeout(async()=>{const u=new C({QueryExecutionId:c.QueryExecutionId}),t=await i.send(u);t.$metadata.httpStatusCode!==200&&a(new Error("FailedQuery: unable to query Athena")),t.QueryExecution.Status.State==="SUCCEEDED"?n(t):t.QueryExecution.Status.State==="FAILED"?(console.log(t.QueryExecution),a(new Error("FailedQuery: unable to query Athena"))):t.QueryExecution.Status.State==="CANCELLED"?a(new Error("FailedQuery: unable to query Athena")):(t.QueryExecution.Status.State==="RUNNING"||t.QueryExecution.Status.State==="QUEUED")&&(f++,y=e.backoff+f*100,m().then(n).catch(a))},y)});await m().catch(n=>{throw new Error(n)});const h=new S({QueryExecutionId:c.QueryExecutionId}),s=await i.send(h);if(s.$metadata.httpStatusCode!==200)throw new Error("FailedQuery: unable to query Athena");const o=s.ResultSet.ResultSetMetadata.ColumnInfo.map(n=>({name:n.Name,type:n.Type}));s.ResultSet.Rows.shift();const b=s.ResultSet.Rows.map(n=>{const a={};return n.Data.forEach((u,t)=>{if(Object.keys(u).length===0||u.VarCharValue===null)return;const r=o[t].type;if(r==="date"||r==="timestamp"){a[o[t].name]=new Date(u.VarCharValue);return}if(r==="tinyint"||r==="smallint"||r==="integer"||r==="bigint"){a[o[t].name]=parseInt(u.VarCharValue);return}if(r==="double"||r==="float"||r==="decimal"){a[o[t].name]=parseFloat(u.VarCharValue);return}r==="boolean"&&(a[o[t].name]=u.VarCharValue==="true"),a[o[t].name]=u.VarCharValue}),a});return{columns:o,rows:b}}export{A as query};
